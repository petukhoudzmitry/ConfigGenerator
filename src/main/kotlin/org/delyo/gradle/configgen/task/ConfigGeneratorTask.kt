package org.delyo.gradle.configgen.task

import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.TypeSpec
import org.delyo.gradle.configgen.data.ConfigMapping
import org.delyo.gradle.configgen.service.PropertiesExtractor
import org.delyo.gradle.configgen.service.contract.Extractor
import org.gradle.api.DefaultTask
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.model.ObjectFactory
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.*
import java.io.File
import javax.inject.Inject

@Suppress("UNCHECKED_CAST")
@CacheableTask
open class ConfigGeneratorTask @Inject constructor(@Internal val objects: ObjectFactory) : DefaultTask() {
    @get:Input
    val defaultClassName: Property<String> = objects.property(String::class.java)

    @get:Input
    val outputPackage: Property<String> = objects.property(String::class.java)

    @get:Input
    val language: Property<String> = objects.property(String::class.java)

    @get:InputFiles
    val inputFiles: ConfigurableFileCollection = project.objects.fileCollection()

    @get:OutputDirectory
    val outputDirectory = objects.directoryProperty()

    init {
        group = "build"
        description = "Generate config classes"
    }

    @TaskAction
    fun generate() {
        val outputDir = outputDirectory.get().asFile

        val configMappings: ListProperty<ConfigMapping> =
            project.objects.listProperty(ConfigMapping::class.java)

        inputFiles.filter { it.exists() }.forEach { file ->
            configMappings.add(objects.newInstance(ConfigMapping::class.java).apply {
                inputFiles.from(file)
            })
        }

        val mappings = if (configMappings.orNull?.isEmpty() == true) {
            listOf(configMappingFromDefault())
        } else {
            configMappings.get()
        }

        mappings.forEach { mapping ->
            val inputFiles = mapping.inputFiles.files.toList()
            val extractor: Extractor = PropertiesExtractor()


            val extracted = extractor.extract(inputFiles)


            val className = mapping.className ?: defaultClassName.get()

            generateKotlinClass(outputDir, outputPackage.get(), className, extracted)
        }
    }

    private fun configMappingFromDefault(): ConfigMapping {
        val mapping = objects.newInstance(ConfigMapping::class.java)
        mapping.inputFiles = project.files()
        mapping.className = defaultClassName.get()
        mapping.packageName = outputPackage.get()
        mapping.language = language.get()
        return mapping
    }

    private fun generateKotlinClass(
        outputDir: File,
        packageName: String,
        className: String,
        extracted: Map<String, Any?>
    ) {
        val fileBuilder = FileSpec.builder(packageName, className)
        val typeBuilder = TypeSpec.classBuilder(className).addKdoc("Generated by ConfigGeneratorPlugin")

        val companionBuilder = TypeSpec.companionObjectBuilder()

        for ((key, value) in extracted) {
            when (value) {
                is Map<*, *> -> {
                    val nestedName = safePropertyName(key).capitalizeSafe()
                    val nestedBuilder =
                        TypeSpec.objectBuilder(nestedName).addKdoc("Represents structure '$key' from config")

                    (value as Map<String, Any?>).forEach { (nestedKey, nestedValue) ->
                        val propertyName = safePropertyName(nestedKey)

                        nestedBuilder.addFunction(
                            FunSpec.builder("get_$propertyName").returns(String::class.java)
                                .addStatement(
                                    "return System.getenv(%S) ?: %S",
                                    nestedKey,
                                    nestedValue?.toString() ?: ""
                                )
                                .build()
                        )
                    }
                    companionBuilder.addType(nestedBuilder.build())
                }

                else -> {
                    val propName = safePropertyName(key)
                    companionBuilder.addFunction(
                        FunSpec.builder("get_$propName")
                            .returns(String::class)
                            .addStatement("return System.getenv(%S) ?: %S", key, value?.toString() ?: "")
                            .build()
                    )
                }
            }
        }
        typeBuilder.addType(companionBuilder.build())
        fileBuilder.addType(typeBuilder.build())
        fileBuilder.build().writeTo(outputDir)
    }

    private fun safePropertyName(name: String): String {
        return name.replace('.', '_').replace('-', '_')
    }


    private fun String.capitalizeSafe(): String {
        return if (this.isEmpty()) this else this[0].uppercaseChar() + this.substring(1)
    }
}