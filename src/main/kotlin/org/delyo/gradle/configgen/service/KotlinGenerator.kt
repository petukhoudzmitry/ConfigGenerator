package org.delyo.gradle.configgen.service

import com.squareup.kotlinpoet.*
import org.delyo.gradle.configgen.service.contract.AbstractGenerator
import java.io.File
import java.util.*

@Suppress("UNCHECKED_CAST")
class KotlinGenerator : AbstractGenerator() {
    override fun generate(
        srcFile: File,
        outputDir: File,
        packageName: String,
        className: String,
        extracted: Map<String, Any?>
    ) {
        val fileBuilder = FileSpec.builder(packageName, className).indent("    ")
        val typeBuilder = TypeSpec.classBuilder(className).addKdoc("Generated by ConfigGeneratorPlugin")

        fileBuilder.addImport("java.util", "Properties")
        fileBuilder.addImport("java.nio.file", "Files", "Paths")

        val companionBuilder = TypeSpec.companionObjectBuilder()

        for ((key, value) in extracted) {
            println("Value: $value")
            when (value) {
                is Map<*, *> -> {
                    val nestedName = safePropertyName(key)
                    val nestedBuilder =
                        TypeSpec.objectBuilder(nestedName).addKdoc("Represents structure '$key' from config")

                    nestedBuilder.addProperty(
                        PropertySpec.builder("properties", Properties::class.java).addModifiers(KModifier.PRIVATE)
                            .initializer(CodeBlock.of("Properties()")).build()
                    )
                    nestedBuilder.addInitializerBlock(
                        CodeBlock.of(
                            "Files.newBufferedReader(Paths.get(%S)).use { reader -> properties.load(reader) }\n",
                            srcFile.absolutePath
                        )
                    )

                    (value as Map<String, Any>).forEach { (nestedKey, nestedValue) ->
                        val propertyName = safePropertyName(nestedKey)

                        nestedBuilder.addProperty(
                            PropertySpec.builder(propertyName, String::class).getter(
                                FunSpec.getterBuilder()
                                    .addStatement("return properties[%S] as String", "$key.$nestedKey").build()
                            ).build()
                        )
                    }
                    typeBuilder.addType(nestedBuilder.build())
                }

                else -> {
                    val propName = safePropertyName(key)
                    companionBuilder.addProperty(
                        PropertySpec.builder(propName, String::class).getter(
                            FunSpec.getterBuilder().addStatement("return properties[%S] as String", value as Any)
                                .build()
                        ).build()
                    )
                }
            }
        }
        if (companionBuilder.originatingElements.isNotEmpty()) {
            typeBuilder.addType(companionBuilder.build())
        }
        fileBuilder.addType(typeBuilder.build())
        fileBuilder.build().writeTo(outputDir)
    }
}